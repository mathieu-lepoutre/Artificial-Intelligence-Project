---
title: "AI project"
author: "Mathieu Lepoutre"
date: "2020 - 2021 "
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(keras)
library(readr)
library(data.table)
library(magrittr)
library(anytime)
library(igraph)
library(sp)
library(reticulate)
library(lattice)
library(ggplot2)
library(caret)


use_python("/usr/local/bin/python")
```

```{python}
import datetime
import csv
import pandas as pd
from IPython.display import Image
```

## Predicting a ship's destination based on it's beginning's latitude and longitude.

Wouldn't it be great if we could predict a ship's destination ?

In this paper I will try to tackle this challenge.

For input there is an unprocessed dataset containing a ship's ID and it's total trajectory.
The data isn't always that accurate since a ship's owner will sometimes cancel a ship's beacon.

First the data will be processed, this challenge is made up of two steps. I made a paint picture to explain it visually.

The first step is to split the data based on a time delta. 

You have to ask yourself these question, "why is the time difference between two registries sometimes a big difference ?" and  "When would an owner stop the beacon from sending location data ?"

The answer is that the owner will stop the transmitting of the beacon when he is asleep or docked. This ofcourse makes the data inaccurate. That's why I first split the dataset on a timedelta. 

The total trajectory of a ship will be split in real trajectories.

The next split will be done based on how fast the ship is moving. If it is moving below a certain threshold (this can't be zero because the current can't be dismissed), the ship most likely has stopped and reached it's destination.



To train my neural network I need to be sure the data is in the correct format.
The preferable format is the ship's start position (latitude and longitude), the ship's end position (latitude and longitude) and the time delta between the two positions.


## Processing the unprocessed data

```{python}
unprocessed = pd.read_csv("schipsdataset.csv",sep=';')
```

```{python}
unprocessed.head(10)
```

This visually explains the steps I'm going to partake.

```{python}
Image(filename='preprocessing.png')
```

Changeable variables to alter the output file. If you believe the time delta when the owner puts off the beacon is shorter or longer, this can be adjusted here. This can also be done with the speed delta.

```{python}
timedelta = 36000 #1 hour
speedDelta = 2     #2 meter per second
```



```{python}
f = open("schipsdataset.csv")
```

```{python}
fileData = f.readlines()
List = []
outputList = []
```


```{python}
def getTime(tuple):
    return (tuple[0]*60) + tuple[1]
```



```{python}
data = []
for d in fileData:
    temp = d.replace(";",",")
    data.append(temp.split(","))
  
List.append(data[1])
```



```{python}
def splitList(List):
    if(len(List)<1):
        return 0
    newList = []
    newList.append(List[0])
    route = 1
    for i in range(1,len(List)):
        
        if(len(List[i]) > 7):
            if((not (List[i][7]=="") )and (not(newList[len(newList)-1][7] == "") )):
                if((not (List[i][7]=="NULL") )and (not(newList[len(newList)-1][7] == "NULL") )):
                    if(not (List[i][7].rstrip("\n") is None)):
                        if(not (newList[len(newList)-1][7].rstrip("\n") is None)):
                                speedDiff = int(List[i][7]) - int(newList[len(newList)-1][7])
                                if(speedDiff < speedDelta):
                                    newList.append(List[i])
                                else:
                                    d = []
                                    d.append(newList[0][0])
                                    d.append(route)
                                    route = route + 1
                                    d.append(newList[0][2] + "." +newList[0][3])
                                    d.append(newList[0][4] + "." +newList[0][5])
                                    
                                    d.append(newList[len(newList)-1][2] + "."+newList[len(newList)-1][3])
                                    d.append(newList[len(newList)-1][4] + "."+newList[len(newList)-1][5])
                                                                        
                                    
                                    time1 = datetime.datetime.strptime(newList[0][1], '%Y-%m-%d %H:%M:%S.%f')
                                    time2 = datetime.datetime.strptime(newList[len(newList)-1][1], '%Y-%m-%d %H:%M:%S.%f')
                                    timeDiff = time2 - time1
                                    tup = divmod(timeDiff.total_seconds(), 60)    
                                    d.append(getTime(tup))
                                    print(d)
                                    outputList.append(d)
                                    newList = []
                                    newList.append(List[i])
```



```{python}
for i in range(2,len(data)):
    time1 = datetime.datetime.strptime(List[len(List)-1][1], '%Y-%m-%d %H:%M:%S.%f')
    time2 = datetime.datetime.strptime(data[i][1], '%Y-%m-%d %H:%M:%S.%f')
    timeDiff = time2 - time1
    tup = divmod(timeDiff.total_seconds(), 60)
    if(getTime(tup) < timedelta):
        if(len(data[i])>7):
            List.append(data[i])
    else:
        splitList(List)
        List = []
```


```{python}
List.append(data[i])
```


```{python}
with open('output.csv', mode='w') as output_file:
    output_writer = csv.writer(output_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    for data in outputList:        
        output_writer.writerow(data)
```


The dataset has been splitted and it is now time to delete null values and place column names.

```{python}
sdata = pd.read_csv("output.csv",sep=',',names=["shipid","routeid","startLongitude","startLatitude","endlongitude","endlatitude","timedelta"])
```


```{python}
sdata=sdata[sdata.timedelta!=0]
sdata=sdata[sdata.timedelta>0]
```

```{python}
sdata.head(10)
```

```{python}
sdata.to_csv(r'processeddata.csv',sep='\t', index=False)
```

The data has now been processed.

Each ship's route is now a single row, with its ID, starting latitude & longitude and its end latitude & longitude. The time delta between two destinations is also included.


Now it's time to start exploring neural networks.

The goal is to accurately predict a correct destination's latitude and longitude, based on the start latitude and longitude. This
will be achieved by training the model on the thousands of trajects that happened in the past.


This prediction can be useful in many applications and situations.


```{r}
pdata <- read.csv("processeddata.csv", sep = "")

dim(pdata)

str(pdata)

summary(data)
```

## Neural networks

First we need to split the dataset into training and test sets. The model will be trained on the trained set, and then the model can start predicting on the test set.
The training control needs to be defined.

There are lots of neural networks. The first one is the nnet neural network.

By setting the seed, the partition will be reproducible.


```{r}
pdata = pdata[1:10000,]
set.seed(1)

```


```{r}
smp_size <- floor(0.70 * nrow(pdata))
train_ind <- sample(seq_len(nrow(pdata)), size = smp_size)
train <- pdata[train_ind, ]
test <- pdata[-train_ind, ]


```


```{r}
train_control <- trainControl(method="repeatedcv",repeats = 3)
```

Building the neural network for the longitude.

```{r}

nn_Lon <- train(endlongitude ~ startLongitude + startLatitude + timedelta ,
               data = train,
               trControl = train_control,
               method = "nnet", 
               linout = TRUE)
nn_Lon

```
Building the neural network for the latitude

```{r}
nn_Lat <- train(endlatitude ~ startLongitude + startLatitude + timedelta ,
                data = train,
                trControl = train_control,
                method = "nnet", 
                linout = TRUE)
nn_Lat
```

Now we can evaluate the model on test data, and see the predictions.

```{r}
# Evaluating the models on test data

pred_nn_lon <- predict(nn_Lon,newdata = test)
pred_nn_lat <- predict(nn_Lat,newdata = test)

res_nn= cbind(pred_nn_lon,pred_nn_lon,test$endlongitude,test$endlatitude)
colnames(res_nn) = c("Pred_Lon","Pred_Lat","actual_Lon","actual_Lat")


```


```{r}
res_nn
```

The next neural network will be the K-nearest neighbor algorithm network.
First we train the model on the training set.


```{r}

model_Lon <- train(endlongitude ~ startLongitude + startLatitude + timedelta ,
                   data = train,
                   trControl = train_control,
                   method = "knn", 
                   preProcess = c("center","scale"), tuneLength = 20)
model_Lon
```


```{r}
model_Lat <- train(endlatitude ~ startLongitude + startLatitude + timedelta ,
                   data = train,
                   trControl = train_control,
                   method = "knn", 
                   preProcess = c("center","scale"), tuneLength = 20)
model_Lat
```

Now let's evaluate the models on the test data.

```{r}

pred_lon <- predict(model_Lon,newdata = test)
pred_lat <- predict(model_Lat,newdata = test)

res_knn= cbind(pred_lon,pred_lat,test$endlongitude,test$endlatitude)
colnames(res_knn) = c("Pred_Lon","Pred_Lat","actual_Lon","actual_Lat")
```


```{r}
res_knn
```


The next goal is to make neural networks to accurately predict the time delta between a ship's startings positioning and a ship's destination positioning.

The time delta in this context is the time traveled between the two places.


First we build the neural network.

```{r}

nn_time <- train(timedelta ~ startLongitude + startLatitude + endlatitude + endlongitude ,
               data = train,
               trControl = train_control,
               method = "nnet", 
               linout = TRUE)
nn_time

```


Now we can evaluate the model on test data, and see the predictions.

```{r}
# Evaluating the models on test data

pred_nn_time <- predict(nn_time,newdata = test)


res_nn= cbind(pred_nn_time,test$timedelta)
colnames(res_nn) = c("Pred_time","actual_time")


```


```{r}
res_nn
```

K-nearest neighbor algorithm network:


```{r}

model_knn_timedelta <- train(timedelta ~ startLongitude + startLatitude + endlatitude + endlongitude ,
                   data = train,
                   trControl = train_control,
                   method = "knn", 
                   preProcess = c("center","scale"), tuneLength = 20)
model_knn_timedelta
```



Now let's evaluate the models on the test data.

```{r}

pred_time <- predict(model_knn_timedelta,newdata = test)


times_knn= cbind(pred_time,test$timedelta)
colnames(times_knn) = c("Pred_time","actual_time")
```


```{r}
times_knn
```


```{r}

```



