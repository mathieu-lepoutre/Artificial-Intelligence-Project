---
title: "markdown"
author: "Mathieu Lepoutre"
date: "28-11-2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(keras)
library(readr)
library(data.table)
library(magrittr)
library(anytime)
library(igraph)
library(sp)
library(reticulate)


use_python("C:\\Program Files\\Python37")
```

```{python}
import datetime
import csv
import pandas as pd
from IPython.display import Image
```

## Predicting a ship's destination based on it's beginning's latitude and longitude.

Wouldn't it be great if we could predict a ship's destination ?

In this paper I will try to tackle this challenge.

For input there is an unprocessed dataset containing a ship's ID and it's total trajectory.
The data isn't always that accurate since a ship's owner will sometimes cancel a ship's beacon.

First the data will be processed, this challenge is made up of two steps. I made a paint picture to explain it visually.

The first step is to split the data based on a time delta. 

You have to ask yourself these question, "why is the time difference between two registries sometimes a big difference ?" and  "When would an owner stop the beacon from sending location data ?"

The answer is that the owner will stop the transmitting of the beacon when he is asleep or docked. This ofcourse makes the data inaccurate. That's why I first split the dataset on a timedelta. 

The total trajectory of a ship will be split in real trajectories.

The next split will be done based on how fast the ship is moving. If it is moving below a certain threshold (this can't be zero because the current can't be dismissed), the ship most likely has stopped and reached it's destination.



To train my neural network I need to be sure the data is in the correct format.
The preferable format is the ship's start position (latitude and longitude), the ship's end position (latitude and longitude) and the time delta between the two positions.



```{python}
unprocessed = pd.read_csv("schipsdataset.csv",sep=';')
```

```{python}
unprocessed.head(10)
```

This visually explains the steps I'm going to partake.

```{python}
Image(filename='preprocessing.png')
```

Changeable variables to alter the output file. If you believe the time delta when the owner puts off the beacon is shorter or longer, this can be adjusted here. This can also be done with the speed delta.

```{python}
timedelta = 36000 #1 hour
speedDelta = 2     #2 meter per second
```



```{python}
f = open("schipsdataset.csv")
```

```{python}
fileData = f.readlines()
List = []
outputList = []
```


```{python}
def getTime(tuple):
    return (tuple[0]*60) + tuple[1]
```



```{python}
data = []
for d in fileData:
    temp = d.replace(";",",")
    data.append(temp.split(","))
  
List.append(data[1])
```




```{python}
def splitList(List):
    if(len(List)<1):
        return 0
    newList = []
    newList.append(List[0])
    route = 1
    for i in range(1,len(List)):
        
        if(len(List[i]) > 7):
            if((not (List[i][7]=="") )and (not(newList[len(newList)-1][7] == "") )):
                if((not (List[i][7]=="NULL") )and (not(newList[len(newList)-1][7] == "NULL") )):
                    if(not (List[i][7].rstrip("\n") is None)):
                        if(not (newList[len(newList)-1][7].rstrip("\n") is None)):
                                speedDiff = int(List[i][7]) - int(newList[len(newList)-1][7])
                                if(speedDiff < speedDelta):
                                    newList.append(List[i])
                                else:
                                    d = []
                                    d.append(newList[0][0])
                                    d.append(route)
                                    route = route + 1
                                    d.append(newList[0][2] + "." +newList[0][3])
                                    d.append(newList[0][4] + "." +newList[0][5])
                                    
                                    d.append(newList[len(newList)-1][2] + "."+newList[len(newList)-1][3])
                                    d.append(newList[len(newList)-1][4] + "."+newList[len(newList)-1][5])
                                                                        
                                    
                                    time1 = datetime.datetime.strptime(newList[0][1], '%Y-%m-%d %H:%M:%S.%f')
                                    time2 = datetime.datetime.strptime(newList[len(newList)-1][1], '%Y-%m-%d %H:%M:%S.%f')
                                    timeDiff = time2 - time1
                                    tup = divmod(timeDiff.total_seconds(), 60)    
                                    d.append(getTime(tup))
                                    print(d)
                                    outputList.append(d)
                                    newList = []
                                    newList.append(List[i])
                                    
                                    
                                
```



```{python}
for i in range(2,len(data)):
    time1 = datetime.datetime.strptime(List[len(List)-1][1], '%Y-%m-%d %H:%M:%S.%f')
    time2 = datetime.datetime.strptime(data[i][1], '%Y-%m-%d %H:%M:%S.%f')
    timeDiff = time2 - time1
    tup = divmod(timeDiff.total_seconds(), 60)
    if(getTime(tup) < timedelta):
        if(len(data[i])>7):
            List.append(data[i])
    else:
        splitList(List)
        List = []
        List.append(data[i])
```

```{python}
with open('output.csv', mode='w') as output_file:
    output_writer = csv.writer(output_file, delimiter=',', quotechar='"', quoting=csv.QUOTE_MINIMAL)
    for data in outputList:        
        output_writer.writerow(data)
```


The dataset has been splitted and it is now time to delete null values and place column names.

```{python}
sdata = pd.read_csv("output.csv",sep=',',names=["shipid","routeid","startLongitude","startLatitude","endlongitude","endlatitude","timedelta"])
```


```{python}
sdata=sdata[sdata.timedelta!=0]
sdata=sdata[sdata.timedelta>0]
```

```{python}
sdata.head(10)
```

```{python}
sdata.to_csv(r'processeddata.csv',sep='\t', index=False)
```

The data has been processed.

Each ship's route is now a single row, with its ID, the start latitude and longitude, the end latitude and longitude and the time delta.


Now it's time to start exploring recurrent neural networks, and specifically long short term memory neural networks.

The goal is to predict a ship's destination based on it's start data.

This can be achieved by training the model on the thousands of trajects that happened in the past.


```{r}
py$sdata 

pdata <- fread("processeddata.csv")

dim(pdata)

str(pdata)

summary(pdata)

```



```{r}
pdata$shipid %>% plot

```

todo;

- neuraal netwerk
  -ship destination
  -time delta
  
- meta data toevoegen


```{r}

data_mat = as.matrix(pdata[, c(2,3,5,7)])

set.seed(17)
ind <- sample(2, nrow(data_mat),
              replace = TRUE, prob = c(0.7, 0.3))
data.training <- data_mat[ind == 1, c(1,2,4)]
data.test <- data_mat[ind == 2, c(1,2,4)]
data.trainingtarget <- data_mat[ind == 1, -c(1,2,4)]
data.testtarget <- data_mat[ind == 2, -c(1,2,4)]



```


```{r}
model <- keras_model_sequential()
model %>%
  layer_dense(units = 1, activation = 'relu',
              input_shape = ncol(data.training))
summary(model)



```

```{r}
model %>% compile(
  loss = 'mse',
  optimizer = "adam",
  metrics = 'accuracy'
)

```



```{r}

history <- model %>% fit(
  x = data.training,
  y = data.trainingtarget,
  epochs = 10,
  batch_size = 5,
  validation_split = 0.3,
  verbose = 1
)

```

```{r}
plot(history)
```















